<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    数据结构与算法笔记 |
    
    一字三木
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-数据结构与算法笔记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  数据结构与算法笔记
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2021-12-07T13:22:03.000Z" itemprop="datePublished">2021-12-07</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <!-- # 类别

1. 数组
2. 字符串
3. 链表
4. 树
5. 图
6. 回溯算法
7. 排序和搜索
8. 动态规划
9. 设计问题
10.  数学
11.  其他

--- -->

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul>
<li>数据结构基本操作，<code>遍历</code> + <code>访问</code>，具体一点：<code>增</code>、<code>删</code>、<code>查</code>、<code>改</code>（改=读+写）</li>
<li>数据结构的底层存储方式：数组（顺序存储）和链表（链式存储），数组<code>查</code>、<code>改</code>快，链表<code>增</code>、<code>删</code>快</li>
<li>遍历框架：<ul>
<li>线性形式：for/while 迭代；</li>
<li>非线性形式：递归</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-栈-OI-Wiki"><a href="#1-栈-OI-Wiki" class="headerlink" title="1. 栈 [OI Wiki]"></a>1. 栈 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/stack/">[OI Wiki]</a></h2><p><img src="/images/stack.svg"></p>
<p>后进先出 LIFO（last in first out），push 入栈，pop 出栈</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用列表来模拟栈</span></span><br><span class="line">stk = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 append() 向栈顶添加元素</span></span><br><span class="line">stk.append(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 pop 取出栈顶元素</span></span><br><span class="line">stk.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 clear 清空栈</span></span><br><span class="line">stk.clear()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-1-单调栈-OI-Wiki"><a href="#1-1-单调栈-OI-Wiki" class="headerlink" title="1.1 单调栈 [OI Wiki]"></a>1.1 单调栈 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/monotonous-stack/">[OI Wiki]</a></h3><p>满足单调性的栈，如图，单调栈中元素，从上到下，0 &lt; 11 &lt; 45 &lt; 81</p>
<p><img src="/images/monotonous-stack-before.svg"></p>
<p>当添加元素14时，先将0,11出栈，再将14入栈，确保栈的单调性</p>
<p><img src="/images/monotonous-stack-after.svg"></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487704&idx=1&sn=eb9ac24c644aa0950638c9b20384e982&scene=21#wechat_redirect">博客</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-i/">leetcode 496. 下一个更大元素 I</a></p>
<hr>
<h2 id="2-队列-OI-Wiki"><a href="#2-队列-OI-Wiki" class="headerlink" title="2. 队列 [OI Wiki]"></a>2. 队列 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/queue/">[OI Wiki]</a></h2><p><img src="/images/queue.svg"></p>
<p>先进先出FIFO（first in first out），push 入队，pop 出队</p>
<h3 id="2-1-双端队列"><a href="#2-1-双端队列" class="headerlink" title="2.1 双端队列"></a>2.1 双端队列</h3><p>可以在队首/队尾插入或删除元素的队列，相当于是栈与队列功能的结合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">queue = deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">queue.append(<span class="number">4</span>)</span><br><span class="line">queue.appendleft(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最右侧数字4出队</span></span><br><span class="line">right_num = queue.pop()</span><br><span class="line"><span class="comment"># 最左侧数字0出队</span></span><br><span class="line">left_num = queue.popleft()</span><br><span class="line"><span class="comment"># [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空队列</span></span><br><span class="line">queue.clear()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-单调队列-OI-Wiki"><a href="#2-2-单调队列-OI-Wiki" class="headerlink" title="2.2 单调队列 [OI Wiki]"></a>2.2 单调队列 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/monotonous-queue/">[OI Wiki]</a></h3><p>队列从队头到队尾，元素大小单调；</p>
<hr>
<h2 id="3-链表-OI-Wiki"><a href="#3-链表-OI-Wiki" class="headerlink" title="3. 链表 [OI Wiki]"></a>3. 链表 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/linked-list/">[OI Wiki]</a></h2><h3 id="3-2-遍历框架"><a href="#3-2-遍历框架" class="headerlink" title="3.2 遍历框架"></a>3.2 遍历框架</h3><ol>
<li>迭代遍历，while循环，直到走到链表尾部或者触发某条件停止</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链表单结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">head: Node</span>):</span></span><br><span class="line">    p = head</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        <span class="built_in">print</span>(p.value)</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举个栗子：删除倒数第n个结点</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china">leetcode 19. 删除链表的倒数第 N 个结点</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [1, 2, 3, 4, 5], 删除倒数第n == 2个，即删除4，得到[1, 2, 3, 5]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: Node, n: <span class="built_in">int</span></span>) -&gt; Node:</span></span><br><span class="line">    <span class="comment"># left指针，right指针</span></span><br><span class="line">    <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line">    <span class="comment">#  |     </span></span><br><span class="line">    <span class="comment"># l/r</span></span><br><span class="line">    l = head</span><br><span class="line">    r = head</span><br><span class="line"></span><br><span class="line">    <span class="comment"># right指针先跑n == 2步</span></span><br><span class="line">    <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line">    <span class="comment">#  |     |</span></span><br><span class="line">    <span class="comment">#  l     r</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        r = r.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 特殊情况：</span></span><br><span class="line">    <span class="comment"># 如果 n == 5，right指针先跑5步，指向None</span></span><br><span class="line">    <span class="comment"># 此时删除头结点，倒数第五个元素，为head</span></span><br><span class="line">    <span class="comment"># [1, 2, 3, 4, 5] None</span></span><br><span class="line">    <span class="comment">#  |              |</span></span><br><span class="line">    <span class="comment">#  l              r</span></span><br><span class="line">    <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    <span class="comment"># left指针和right指针同时跑，知道right跑到了尾部tail</span></span><br><span class="line">    <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line">    <span class="comment">#        |     |</span></span><br><span class="line">    <span class="comment">#        l     r</span></span><br><span class="line">    <span class="keyword">while</span> r.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        l = l.<span class="built_in">next</span></span><br><span class="line">        r = r.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除left右边的第一个结点，即倒数第n == 2个结点</span></span><br><span class="line">    <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line">    <span class="comment">#        |  删 |</span></span><br><span class="line">    <span class="comment">#        l     r</span></span><br><span class="line">    l.<span class="built_in">next</span> = l.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>递归</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">head: Node</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写在这个位置的代码：前序遍历</span></span><br><span class="line">    <span class="comment"># 比如，print(head.value)，实现正序地打印链表：</span></span><br><span class="line"></span><br><span class="line">    traverse(head.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写在这个位置的代码：后序遍历</span></span><br><span class="line">    <span class="comment"># 比如，print(head.value)，实现倒序地打印链表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="3-1-单向链表"><a href="#3-1-单向链表" class="headerlink" title="3.1 单向链表"></a>3.1 单向链表</h3><p>每个结点保存着：数据，和链表里下一结点的内存地址</p>
<p><img src="/images/list.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value = <span class="literal">None</span>, <span class="built_in">next</span> = <span class="literal">None</span></span>):</span> </span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2-双向链表"><a href="#3-2-双向链表" class="headerlink" title="3.2 双向链表"></a>3.2 双向链表</h3><p>双向链表跟链表差不多，只是它每个结点都含有两个链：一个指向下一结点，另一个指向前一结点。此外，它还能直接访问第一个和最后一个结点</p>
<p><img src="/images/double-list.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value = <span class="literal">None</span>, left = <span class="literal">None</span>, right = <span class="literal">None</span></span>):</span> </span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><h3 id="4-1-二叉堆-OI-Wiki"><a href="#4-1-二叉堆-OI-Wiki" class="headerlink" title="4.1 二叉堆 [OI Wiki]"></a>4.1 二叉堆 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/binary-heap/">[OI Wiki]</a></h3><h4 id="4-1-1-结构"><a href="#4-1-1-结构" class="headerlink" title="4.1.1 结构"></a>4.1.1 结构</h4><p>结构上，二叉堆是一棵完全二叉树，每个结点有一个值value</p>
<blockquote>
<p>深度为k的二叉树，结点数为 1 + 2 + 4 + … 2^(k-1) = 2^k - 1，称为满二叉树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 满二叉树</span></span><br><span class="line">     <span class="number">0</span> </span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">1</span>     <span class="number">2</span>   </span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> <span class="number">5</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>一棵满二叉树，从上到下、从左到右，最底层 “满” 或 “未满” 2^(k-1) 个结点，为完全二叉树。满二叉树是完全二叉树的特殊情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完全二叉树</span></span><br><span class="line">     <span class="number">0</span> </span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">1</span>     <span class="number">2</span>   </span><br><span class="line"> / \   / </span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> <span class="number">5</span>   </span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="4-1-2-性质"><a href="#4-1-2-性质" class="headerlink" title="4.1.2 性质"></a>4.1.2 性质</h4><p>性质上，</p>
<ul>
<li>大根堆（别名，最大堆）：父结点的值 &gt;= 子结点的值，堆顶的值最大</li>
<li>小根堆（别名，最小堆）：父结点的值 &lt;= 子结点的值，堆顶的值最小<br>获取数据结构中的最大值（或最小值）在堆顶，获取比较快<br>每次增删结点时候，通过“上浮”和“下潜”，维护堆里值相对大小的性质，确保数据结构中值是有序的<br>优先级队列PriorityQueue是基于此实现的</li>
</ul>
<h4 id="4-1-3-数据结构操作"><a href="#4-1-3-数据结构操作" class="headerlink" title="4.1.3 数据结构操作"></a>4.1.3 数据结构操作</h4><ul>
<li>增：<ol>
<li>将新增结点接到树的最后一个结点（最底层的最右边）的右边，如果已满，就新增1层；</li>
<li>按照大根堆（或小根堆）的性质，将结点“上浮”至合适位置<br><img src="/images/binary_heap_insert.svg" alt="大根堆新增结点"></li>
</ol>
</li>
<li>删：<ol>
<li>将需要删除的结点与最后一个结点交换，直接删除</li>
<li>按照大根堆（或小根堆）的性质，将交换后的结点（原最后一个结点）“下潜”至合适位置</li>
</ol>
</li>
</ul>
<h4 id="4-1-4-实现"><a href="#4-1-4-实现" class="headerlink" title="4.1.4 实现"></a>4.1.4 实现</h4><p>使用数组实现，数组的最后一个元素，即使最后一个结点<br>索引为i的结点的两个子节点是2i和2i+1<br><img src="/images/binary-heap-array.svg" alt="二叉堆实现"></p>
<h4 id="4-1-5-优先级队列"><a href="#4-1-5-优先级队列" class="headerlink" title="4.1.5 优先级队列"></a>4.1.5 优先级队列</h4><p>python的优先级队列，可以用heapq和PriorityQueue <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/p/67642557">[参考博客]</a></p>
<ul>
<li>heapq，默认最小堆</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列表转化为最小堆</span></span><br><span class="line">heapq.heapify(arr)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 入队</span></span><br><span class="line">heapq.heappush(arr, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小元素出队</span></span><br><span class="line">min_num = heapq.heappop(arr)</span><br><span class="line"><span class="built_in">print</span>(min_num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问最小元素</span></span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>PriorityQueue，默认最小堆</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue <span class="keyword">as</span> PQ</span><br><span class="line"></span><br><span class="line">pq = PQ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 入队</span></span><br><span class="line">pq.put(<span class="number">0</span>)</span><br><span class="line">pq.put(<span class="number">3</span>)</span><br><span class="line">pq.put(<span class="number">2</span>)</span><br><span class="line">pq.put(<span class="number">1</span>)</span><br><span class="line">pq.put(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列 &#123;&#125;，队列大小 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(pq.queue, pq.qsize()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小元素出队</span></span><br><span class="line">min_num = pq.get()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最小元素 &#123;&#125;，队列 &#123;&#125;，队列大小 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(min_num, pq.queue, pq.qsize()))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-二叉树"><a href="#5-二叉树" class="headerlink" title="5. 二叉树"></a>5. 二叉树</h2><h3 id="5-1-遍历框架"><a href="#5-1-遍历框架" class="headerlink" title="5.1 遍历框架"></a>5.1 遍历框架</h3><ol>
<li>递归</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二叉树结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    <span class="comment"># 二叉树：</span></span><br><span class="line">    <span class="comment">#      4 </span></span><br><span class="line">    <span class="comment">#    /   \</span></span><br><span class="line">    <span class="comment">#   2     6   </span></span><br><span class="line">    <span class="comment">#  / \   / \</span></span><br><span class="line">    <span class="comment"># 1   3 5   7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归至叶结点，返回</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    ans = []  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写在这个位置的代码：前序遍历，中-&gt;左-&gt;右，4-&gt;2-&gt;1-&gt;3-&gt;6-&gt;5-&gt;7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只是打印的话</span></span><br><span class="line">    <span class="comment"># print(root.value, end=&quot;-&gt;&quot;)</span></span><br><span class="line"></span><br><span class="line">    ans += [root.value]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归左子树</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ans += self.traverse(root.left)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写在这个位置的代码：中序遍历，左-&gt;中-&gt;右，1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归右子树</span></span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ans += self.traverse(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写在这个位置的代码：后序遍历，左-&gt;右-&gt;中，1-&gt;3-&gt;2-&gt;5-&gt;7-&gt;6-&gt;4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>扩展到N叉树遍历</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 树结点，children是一个Node的List</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value=<span class="literal">None</span>, children=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.children = children</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root: Node</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(root.value, end=<span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.children <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">        traverse(child)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># N叉树：</span></span><br><span class="line">    <span class="comment">#      4</span></span><br><span class="line">    <span class="comment">#    /   \</span></span><br><span class="line">    <span class="comment">#   2     6</span></span><br><span class="line">    <span class="comment">#  /    / | \</span></span><br><span class="line">    <span class="comment"># 1   3   5   7</span></span><br><span class="line"></span><br><span class="line">    n6 = Node(<span class="number">7</span>, <span class="literal">None</span>)</span><br><span class="line">    n5 = Node(<span class="number">5</span>, <span class="literal">None</span>)</span><br><span class="line">    n4 = Node(<span class="number">3</span>, <span class="literal">None</span>)</span><br><span class="line">    n3 = Node(<span class="number">1</span>, <span class="literal">None</span>)</span><br><span class="line">    n2 = Node(<span class="number">6</span>, [n4, n5, n6])</span><br><span class="line">    n1 = Node(<span class="number">2</span>, [n3])</span><br><span class="line">    root = Node(<span class="number">4</span>, [n1, n2])</span><br><span class="line"></span><br><span class="line">    traverse(root)  <span class="comment"># 结果：4-&gt;2-&gt;1-&gt;6-&gt;3-&gt;5-&gt;7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-2-二叉搜索树"><a href="#5-2-二叉搜索树" class="headerlink" title="5.2 二叉搜索树"></a>5.2 二叉搜索树</h3><p>二叉搜索树 BST（Binary Search Tree）：任意结点的值要 &gt; 左子树所有结点的值，且要 &lt; 右子树所有结点的值</p>
<p><img src="/images/binary_search_tree.png" alt="二叉搜索树"></p>
<h4 id="5-2-1-判断二叉搜索树的合法性"><a href="#5-2-1-判断二叉搜索树的合法性" class="headerlink" title="5.2.1 判断二叉搜索树的合法性"></a>5.2.1 判断二叉搜索树的合法性</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">leetcode 98. 验证二叉搜索树</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断二叉搜索树的值的规则时，不能只用当前结点和左、右结点比较；</span></span><br><span class="line"><span class="comment"># 需要和整棵左、右子树比较</span></span><br><span class="line"><span class="comment">#   10</span></span><br><span class="line"><span class="comment">#  /  \</span></span><br><span class="line"><span class="comment"># 5   15</span></span><br><span class="line"><span class="comment">#    /  \</span></span><br><span class="line"><span class="comment">#   6   20</span></span><br><span class="line"><span class="comment"># 不是二叉搜索树，只比较左、右结点会误判</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归时候，用min_node、max_node记录当前递归最小值、最大值对应的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">root, min_node, max_node</span>):</span></span><br><span class="line">        <span class="comment"># 叶结点，不再判断，返回True</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 左子树中最小值 &gt;= 当前结点值，错误</span></span><br><span class="line">        <span class="keyword">if</span> min_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root.val &lt;= min_node.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 右子树中最大值 &lt;= 当前结点值，错误</span></span><br><span class="line">        <span class="keyword">if</span> max_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root.val &gt;= max_node.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归进入左子树，最小值结点还不确定，最大值结点是当前结点</span></span><br><span class="line">        <span class="comment"># 递归进入右子树，最大值结点还不确定，最小值结点是当前结点</span></span><br><span class="line">        <span class="keyword">return</span> isValid(root.left, min_node, root) \</span><br><span class="line">            <span class="keyword">and</span> isValid(root.right, root, max_node)  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValid(root, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-增"><a href="#5-2-2-增" class="headerlink" title="5.2.2 增"></a>5.2.2 增</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">leetcode 701. 二叉搜索树中的插入操作</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归，将值为 val 的结点插入到二叉搜索树中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="comment"># 找到空位置，插入结点</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> val == root.val:</span><br><span class="line">        <span class="comment"># 等于当前结点，重复了，不再增加</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">elif</span> val &lt; root.val:</span><br><span class="line">        <span class="comment"># 比当前结点小，增加到当前结点的左子树</span></span><br><span class="line">        root.left =  self.insertIntoBST(root.left, val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 比当前结点大，增加到当前结点的右子树</span></span><br><span class="line">        root.right = self.insertIntoBST(root.right, val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-查"><a href="#5-2-3-查" class="headerlink" title="5.2.3 查"></a>5.2.3 查</h4><p>在二叉搜索树中找到指定值为 val 的结点</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">leetcode 700. 二叉搜索树中的搜索</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="comment"># 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> val == root.val:</span><br><span class="line">        <span class="comment"># 找到了值为val的结点</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">elif</span> val &lt; root.val:</span><br><span class="line">        <span class="comment"># val更小，到当前左子树里寻找</span></span><br><span class="line">        <span class="keyword">return</span> self.searchBST(root.left, val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># val更大，到当前右子树里寻找</span></span><br><span class="line">        <span class="keyword">return</span> self.searchBST(root.right, val)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="5-2-4-删"><a href="#5-2-4-删" class="headerlink" title="5.2.4 删"></a>5.2.4 删</h4><p>先找再删</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找值为key的结点，再进行删除</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> key == root.val:</span><br><span class="line">        <span class="comment"># 找到 key 结点</span></span><br><span class="line">        <span class="comment"># 此处执行删除代码</span></span><br><span class="line">    <span class="keyword">elif</span> key &lt; root.val:</span><br><span class="line">        <span class="comment"># key更小，去左子树找key</span></span><br><span class="line">        root.left = self.deleteNode(root.left, key)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># key更大，去右子树找key</span></span><br><span class="line">        root.right = self.deleteNode(root.right, key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>找到结点后，key结点有三种情况：</p>
<ol>
<li>key结点是末端结点，2个子结点都为空<br>可以直接删除</li>
<li>key结点有1个非空子结点<br>删除key结点，将其非空子结点拼上</li>
<li>key结点有2个非空子结点<br>由于，key结点左子树所有结点的值 &lt; key &lt; key结点右子树所有结点的值<br>删除key结点，需要用左子树中最大值结点替代删除结点，或者用右子树中最小值结点替代删除结点</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">leetcode 450. 删除二叉搜索树中的节点</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> key == root.val:</span><br><span class="line">        <span class="comment"># 找到 key 结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况1：key结点是末端结点，2个子结点都为空</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 上一层递归，将返回值None赋值给入参结点</span></span><br><span class="line">            <span class="comment"># 即这一层递归的root，即找到的key结点，赋值为None后可实现直接删除</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况2：key结点有1个非空子结点</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root.right</span><br><span class="line">        <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root.left</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况3：key结点有2个非空子结点</span></span><br><span class="line">        <span class="comment"># 选择用右子树中最小值结点替代删除结点</span></span><br><span class="line">        minNode = root.right</span><br><span class="line">        <span class="keyword">while</span> minNode.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 右子树的最左边，是右子树中的最小值结点</span></span><br><span class="line">            minNode = minNode.left</span><br><span class="line">        <span class="comment"># 替换结点的值</span></span><br><span class="line">        root.val = minNode.val</span><br><span class="line">        <span class="comment"># 改为删除minNode</span></span><br><span class="line">        root.right = self.deleteNode(root.right, minNode.val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> key &lt; root.val:</span><br><span class="line">        <span class="comment"># key更小，去当前左子树找key</span></span><br><span class="line">        root.left = self.deleteNode(root.left, key)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># key更大，去当前右子树找key</span></span><br><span class="line">        root.right = self.deleteNode(root.right, key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-并查集-OI-Wiki-Wikipedia"><a href="#6-并查集-OI-Wiki-Wikipedia" class="headerlink" title="6. 并查集 [OI Wiki] [Wikipedia]"></a>6. 并查集 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/dsu/">[OI Wiki]</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86">[Wikipedia]</a></h2><p>一种树形的数据结构（并查集，Disjoint-set data structure，直译为不交集数据结构，也称为Union-find data structure），用于处理一些不交集（Disjoint sets，一系列没有重复元素的集合）的合并（Union）及查询（Find）问题</p>
<ul>
<li>合并：将两个集合合并为一个</li>
<li>查询：查询某个元素属于哪个集合</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 定义并查集 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不交集的个数</span></span><br><span class="line">    <span class="comment"># （&quot;动态联通性&quot;问题中的连通分量个数，树的话，有几颗独立的树）</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 记录每个结点的父结点</span></span><br><span class="line">    parent = []</span><br><span class="line">    <span class="comment"># 记录每棵树的大小</span></span><br><span class="line">    size = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 构造并查集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param n: 并查集结点的个数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始有n个结点，n棵&quot;树&quot;</span></span><br><span class="line">        self.count = n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义root结点的父结点是自己</span></span><br><span class="line">        <span class="comment"># 初始每棵&quot;树&quot;的大小是1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            self.parent.append(i)</span><br><span class="line">            self.size.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 将包含结点x和结点y的两棵树合并（Union）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param x: 结点1</span></span><br><span class="line"><span class="string">        :param y: 结点2</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 找到结点x、y的根结点</span></span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 结点x和结点y是同一棵树上的结点，不需要合并，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> root_x <span class="keyword">is</span> root_y:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将小树拼到大树下</span></span><br><span class="line">        <span class="comment"># 这么做的目的，可以使得合并后的树比较平衡</span></span><br><span class="line">        <span class="keyword">if</span> self.size[root_x] &lt; self.size[root_y]:</span><br><span class="line">            self.parent[root_x] = root_y</span><br><span class="line">            self.size[root_y] += self.size[root_x]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.parent[root_y] = root_x</span><br><span class="line">            self.size[root_x] += self.size[root_y]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 减少不交集个数，即合并后，树的总量减少1</span></span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, x: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 在所有树🌲上找到结点x，并返回这棵🌲的根结点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param x: 查找的结点</span></span><br><span class="line"><span class="string">        :return: 存在结点x的树🌲的根结点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 循环停止条件，找到node的根结点，父结点==自己</span></span><br><span class="line">        <span class="keyword">while</span> self.parent[x] != x:</span><br><span class="line">            <span class="comment"># 路径压缩</span></span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            <span class="comment">#    1                1                 1</span></span><br><span class="line">            <span class="comment">#   / \              / \               / \</span></span><br><span class="line">            <span class="comment">#  0   2            0   2             0   2</span></span><br><span class="line">            <span class="comment">#       \      -&gt;        \     -&gt;        / \</span></span><br><span class="line">            <span class="comment">#        3                3             4  (3)</span></span><br><span class="line">            <span class="comment">#         \              / \               /</span></span><br><span class="line">            <span class="comment">#          4            5  (4)             5</span></span><br><span class="line">            <span class="comment">#           \</span></span><br><span class="line">            <span class="comment">#           (5)</span></span><br><span class="line">            <span class="comment">#               </span></span><br><span class="line">            <span class="comment">#  (结点) 表示遍历路径</span></span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            <span class="comment"># parent[5] 原本是 4</span></span><br><span class="line">            <span class="comment"># parent[5] = parent[parent[5]] = 3</span></span><br><span class="line">            <span class="comment"># 即将结点5，拼到了结点3下面</span></span><br><span class="line">            <span class="comment"># 第二次，将结点4拼到了结点2下面</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># 路径压缩：沿着遍历”路径“进行压缩，使得🌲高变低</span></span><br><span class="line">            self.parent[x] = self.parent[self.parent[x]]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 向上遍历（朝根结点方向）</span></span><br><span class="line">            x = self.parent[x]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 判断结点x和结点y是否在1棵树🌲上</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param x:</span></span><br><span class="line"><span class="string">        :param y:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.find(x) == self.find(y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中有两个优化：</p>
<ol>
<li><strong>小树拼到大树</strong>：合并的时候，小树拼到大树下。多次合并后，不会出现特别高的树，导致查询速度变慢</li>
<li><strong>路径压缩</strong>：在查询过程中，沿着遍历路径，对树高进行压缩；<br>注意：在合并函数中就调用了查询函数，也就是说，树（一开始是1个结点）一棵棵拼起来过程中，就进行了路径压缩，合并后的树不会出现例子中这么高的树</li>
</ol>
<hr>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>复杂度 <a target="_blank" rel="noopener" href="https://oi-wiki.org/basic/complexity/">[OI Wiki]</a></p>
<ul>
<li><p><strong>基本操作数</strong>：计算机计算能力有区别，使用基本操作的计数或是估测来评判算法用时。<br>基本操作，如加、减、乘、除、访问、赋值等</p>
</li>
<li><p><strong>时间复杂度</strong>：算法用时随数据规模而增长的趋势。<br>分最坏时间复杂度和平均时间复杂度<br>常用大O表示</p>
</li>
</ul>
<hr>
<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h2><p>动态规划（Dynamic Programming, DP）：把原问题分解为相对简单的子问题，以此求解复杂问题。并不是某种具体的算法，而是解决特定问题的方法。</p>
<p>动态规划问题一般是求最值，求最值的首先想可不可以穷举，即找到所有可能的最值。<br>暴露穷举不可取时，考虑有“重叠子问题”的存在，使用“备忘录”或“DP table”来记录计算过的值，优化穷举。</p>
<p>动态规划问题一定有“最优子结构”，子问题的最值才能得到原问题的最值。</p>
<p>动态规划问题需要列出正确的“状态转移方程”，才能正确地穷举。</p>
<h3 id="凑零钱"><a href="#凑零钱" class="headerlink" title="凑零钱"></a>凑零钱</h3><blockquote>
<p>问题：<br>给你一个整数数组<strong>coins</strong>，表示不同面额的硬币；以及一个整数<strong>amount</strong>，表示总金额<br>计算并返回可以凑成总金额所需的<strong>最少的硬币个数</strong>，如果没有任何一种硬币组合能组成总金额，返回-1。<br>你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<p>状态转移方程：<br>$$<br>dp(n) =<br>\begin{cases}<br>0       &amp; {n = 0} \<br>INF     &amp; n &lt; 0 \<br>min{dp(n - coin) + 1 | coin \in coins}  &amp; n &gt; 0<br>\end{cases}<br>$$</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">leetcode 322. 零钱兑换</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>


<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>给定一个数组，找到最长严格递增子序列的长度。子序列与子串不同，子串一定是连续的，子序列不一定是连续的<br>例如：数组[0,3,1,6,2,2,7]的最长递增子序列是[3,6,2,7]，长度是4</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">leetcode 300. 最长递增子序列</a></p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h4><h4 id="子集背包"><a href="#子集背包" class="headerlink" title="子集背包"></a>子集背包</h4><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><hr>
<h2 id="2-搜索"><a href="#2-搜索" class="headerlink" title="2. 搜索"></a>2. 搜索</h2><hr>
<h3 id="2-1-二分搜索"><a href="#2-1-二分搜索" class="headerlink" title="2.1 二分搜索"></a>2.1 二分搜索</h3><hr>
<h3 id="2-2-DFS"><a href="#2-2-DFS" class="headerlink" title="2.2 DFS"></a>2.2 DFS</h3><hr>
<h3 id="2-3-BFS"><a href="#2-3-BFS" class="headerlink" title="2.3 BFS"></a>2.3 BFS</h3><hr>
<h3 id="2-4-回溯"><a href="#2-4-回溯" class="headerlink" title="2.4 回溯"></a>2.4 回溯</h3><hr>
<h2 id="3-排序"><a href="#3-排序" class="headerlink" title="3. 排序"></a>3. 排序</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>遍历数组，两两比较，冒泡（大于或小于）就交换；多次遍历，直到没有冒泡的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">a</span>):</span></span><br><span class="line">    len_of_a = <span class="built_in">len</span>(a)</span><br><span class="line">    bubble_done = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> bubble_done:</span><br><span class="line">        bubble_done = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_of_a - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> a[i] &gt; a[i + <span class="number">1</span>]:</span><br><span class="line">                a[i], a[i+<span class="number">1</span>] = a[i+<span class="number">1</span>], a[i]</span><br><span class="line">                bubble_done = <span class="literal">False</span></span><br><span class="line">        len_of_a -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p>遍历数组，记录最小值，将最小值与第一个元素交换；从第二个位置再次遍历数组，再次记录最小值，交换；反复，知道排序完成</p>
<p>冒泡排序和选择排序的时间复杂度都是O(N^2)</p>
<h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><p>从第二个元素开始，拿出该元素和左边进行比较，比拿出元素大的值，往右移动，找到合适位置，插入该元素；反复，知道拿出最后1个元素比较，并插入，从而完成排序。</p>
<p>插入排序的时间复杂度也是O(N^2)，但这都是基于全都逆序的最坏情况评价的，如果考虑最好情况、平均情况，选择排序和插入排序的速度不一样。</p>
<hr>
<h2 id="4-前缀和、差分"><a href="#4-前缀和、差分" class="headerlink" title="4. 前缀和、差分"></a>4. 前缀和、差分</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" data-id="ckxj6tmzk0000aev844qlcta9" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  
  
  

  
  
<div class="vcomments" id="vcomments"></div>

<script src="https://unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  new Valine({
    el: '#vcomments',
    appId: '',
    appKey: '',
    notify: 'false',
    verify: 'true',
    avatar: 'mp',
    pageSize: '10',
    placeholder: '请输入...'
  })
</script>

  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>一字三木 &copy; 2021</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="一字三木"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>